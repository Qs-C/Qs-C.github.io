[{"title":"二分图匹配","url":"/posts/34711169/","content":"\n计导课上无聊，看了二分匹配相关的内容，遂记录\n\n二分图如果一个图的顶点可以分为两个集合，图的所有边的两个顶点分属两个集合，则该图为“二分图” (Bipartite Graph)\n二分图的最大匹配匹配：在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。二分图的应用中，求最大匹配数是最常见的，其他的很多问题都可以转化为求最大匹配数（如最小覆盖数）\nDFS实现匈牙利算法伪代码从一侧点出发，通过相连的线段到达未与其他点匹配的另一侧点，最大匹配数即为符合上述要求的点的个数通过dfs算法实现，从左侧点出发，尝试连接右侧点    int hungary(){        int res&#x3D;0;&#x2F;&#x2F;res初始化，用来记录匹配最大匹配数        memset(linker,-1,sizeof(linker));&#x2F;&#x2F;linker[]用来记录目前右边点的连接情况        for(int l&#x3D;0;l &lt; lN;l++)        {            memset(used,0,sizeof(used));&#x2F;&#x2F;对于该点，初始时未开始与左侧各点连接            if(dfs(u))res++;&#x2F;&#x2F;通过dfs判定上述要求能否成功        }&#x2F;&#x2F;lN为左侧点的个数，l为正在尝试连接的点的序号        return res;&#x2F;&#x2F;返回最大匹配数    }    bool dfs(int l){        for(int r&#x3D;0;r &lt; rN;r++){            if(g[l][r] &amp;&amp; !used[r]){                used[r]&#x3D;1;                if(linker[r]&#x3D;&#x3D;-1 || dfs(linker[r])){                    linker[r]&#x3D;u;                    return 1;                }            }        }        return 0;        &#x2F;r为右边点序号，rN为右边点个数，g[][]记录左右两侧点的连接情况        对于未被尝试连接过的点，如果该点未与其他点连接则直接相连(linker[r]&#x3D;&#x3D;-1)，将右侧点的连接对象标记为该点        若已有左侧点p与其相连，先将该右侧点标记为不可再连，再去考虑点p能否与其他点相连(dfs(linker[r]))，以此类推，最后找到一个左侧点与右侧未与其他相连的点连接，则返回真，匹配数加一，否则匹配数不变&#x2F;    }\n二分图匹配匈牙利算法dfs实现的优劣优点：\n\n算法的邻接矩阵适用于稠密矩阵\n算法实现简洁，易于理解学习缺点：\n时间复杂度O(VE)，V为顶点数，E为边数，对于二分图匹配，理论上存在更快的算法——Hopcrott-Karp算法，该算法利用BFS同时寻找多条互补相交的最短增广路，并在一次迭代中全部用于增广。时间复杂度达到O(sqrt(V)*E),但在规模不大的稀疏图中，由于常数因子较小且易于实现，仍然常用\n\n匈牙利算法的应用示例（最大匹配数及其变式）求最大匹配数广泛应用于任务分配、网络流优化、稳定婚姻问题等领域\n最小顶点覆盖求取最少的顶点，使每条线至少和其中一个顶点关联二分图最小顶点覆盖&#x3D;二分图最大匹配数(koning 定理)\n最大独立数选取最多的点，使任意所选两点均不相连最大独立数&#x3D;最大匹配数\nDAG图的最小路径覆盖对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）最小路径覆盖数 &#x3D; 顶点数 - 最大匹配数\n总结基于DFS算法实现匈牙利算法，本质上还是穷举所有可能，如果DFS学习到位还是非常好理解的\n","categories":["算法"],"tags":["算法"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"2025 TSCTF-J WP","url":"/posts/4c9af485/","content":"AI:Coup给出前中后期策略，然后开roll策略：前期苟，中期挑软柿子打，后期有把握就开原文：Early on, prioritize safe income generation or using the Duke’s Tax for economy, while avoiding unnecessary bluffs. As funds reach 7-9, leverage Coups or Assassinations to target the weakest opponent , accelerating the game to a one-on-one scenario. Maintain resource control to avoid forced Coups at 10, and use challenges sparingly based on opponent patterns—challenge only when bluff probability is high. In late game, concentrate attacks on the remaining player, balancing aggression with survival; for instance, bluff cautiously in head-to-head situations due to higher challenge risks.\nThreeFairy Tales误打误撞，反提示操作，将执剑人temperature拉到70，将情报变成每个字藏在每句话第二个字的一段话，结果ai把输入的话又输出了，通过\n\nCrypto：Cantor’s_gift康托展开数，逐除（n-1-i）！得到打乱序列，还原字符串数字符串长度得到n&#x3D;37初始化factorials&#x3D;[1]n    if n&gt;1:        temp_fact&#x3D;1        for i in range(1,n):            temp_fact&#x3D;i            factorials[i]&#x3D;temp_fact    avail&#x3D;list(range(1,n+1))perm&#x3D;[]X&#x3D;cantor_num还原康托展开，还原随机排序for i in range(n):        fact_val&#x3D;factorials[n-1-i]        index&#x3D;X&#x2F;&#x2F;fact_val        X&#x3D;X%fact_val        element&#x3D;avail.pop(index)        perm.append(element)排序反向，还原字符串inverse_perm&#x3D;[0]*len(perm)for pos,val in enumerate(perm):inverse_perm[val-1]&#x3D;pos+1&#x2F;&#x2F;反向Flag&#x3D;bytearray(len(hint2))    for i in range(len(hint2)):        Flag[i]&#x3D;hint2[inverse_perm[i]-1]\nsign_in异或回去，恢复flag base64解码将字符串转成整型key1&#x3D;int(KEY1,16)key2_xor_key1&#x3D;int(KEY2_XOR_KEY1,16)key2_xor_key3&#x3D;int(KEY2_XOR_KEY3,16)flag_xor_all&#x3D;int(FLAG_XOR_ALL,16)异或回去Key2&#x3D;key2_xor_key1^key1key3&#x3D;key2^key2_xor_key3m&#x3D;flag_xor_all^key1^key2^key3转回字符串hex_str&#x3D;hex(m)[2:]flag_byte&#x3D;bytes.fromhex(hex_str)flag&#x3D;base64.b64decode(flag_bytes).decode(‘utf-8’)\np&#x3D;~qp，q类似取反，q+p&#x3D;32**1023设：p&#x3D;2^(1023)+a2+1q&#x3D;2^(1023)+ b2 1b&#x3D;(2^1022-1)-a带入n解方程得到p，qs&#x3D;3(1&lt;&lt;1023)D&#x3D;ss-4nsqrt_D&#x3D;math.isqrt(D)p&#x3D;(s+sqrt_D)&#x2F;&#x2F;2q&#x3D;(S-sqrt_D)&#x2F;&#x2F;2计算私钥，d&#x3D;pow(e,-1,(p-1)(q-1))phi&#x3D;(p-1)*(q-1)d&#x3D;pow(e,-1,phi)解密m&#x3D;pow(c,d,n)m&#x3D;pow(c,d,n)flag&#x3D;long_to_bytes(m)\n野狐禅Paillier加密还原计算得到yy_vals&#x3D;[]for i in range(150):    c_i&#x3D;ciphertexts[i]raw_i&#x3D;lcg_raws[i]r_i&#x3D;raw_i%n    t_i&#x3D;pow(r_i,n,n2)    inv_t_i&#x3D;pow(t_i,-1,n2)    z_i&#x3D;(c_iinv_t_i)%n2    m_val_i&#x3D;(z_i-1)&#x2F;&#x2F;n    y_vals.append(m_val_i)构建线性关系求解b&#x3D;y_vals[k:2k]A &#x3D;[]    for i in range(k):row&#x3D;[]        for j in range(k):index&#x3D;k+i-1-j        row.append(y_vals[index])    A.append(row)A_matrix&#x3D;Matrix(A)b_vector&#x3D;Matrix(b）c_vector&#x3D;A_matrix.solve(b_vector)coeffs&#x3D;[int(c)for c in c_vector]还原flagn_flag&#x3D;sum(coeffs[j]*(3**j)for j in range(k))flag_bytes &#x3D; long_to_bytes(n_flag)\n\nmiscBadFile打开txt和wav分析需要找出的文件需要找出个人信息，pdf则在010中分析，发现加入了类似网站源码的编码，Txt和wav硬翻，pdf取了内存最大的五个\nMeow根据010打开得到的提示调整解码方式，a-zA-Z0-+&#x2F;&#x3D;，根据绿色深浅调整字符串排序在Cyberchef中解码得到\n卢森堡的秘密卢森堡的首字母就是lsb，简单Lsb隐写\n\nPwnRet打开ida找到&#x2F;bin&#x2F;sh地址0x400794backdoor函数地址：0x400676找到vul函数，得到需要填充缓冲区16+rbp 8字节根据提示找到ret地址0x4006b6，栈对齐提交payload2 &#x3D;b’A’*offset+p64(ret)+p64(backdoor)填充缓冲区+栈平衡+backdoor地址\n\nWebDruid根据提示&#x2F;Druid随便试账号和密码，admin admin过了\nEZ_login根据提示加X-Forward伪造本地管理员然后burpsuit爆破得到密码simple\nEZ_SQL查询返回几列数据 1’ ORDER BY 3 – 成功 4 失败联合查询1’ UNION SELECT 1,2,3 –CONVERT把第一个flag变成 flag USING utf81’ UNION SELECT 1,CONVERT(flag USING utf8), 3 FROM flag – \n","categories":["wp"],"tags":["CTF","wp"]},{"title":"pwn学习记录（其一）","url":"/posts/e04c41db/","content":"","categories":["CTF"],"tags":["CTF","pwn"]}]